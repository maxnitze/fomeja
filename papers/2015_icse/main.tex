\documentclass[conference]{IEEEtran}

\input{mainmac}
\input{pictures}

\title{Formal Methods For Everyone}
\author{%
  \IEEEauthorblockN{Author 1 \quad Author 2 \quad Author 3}
  \IEEEauthorblockA{%
    $^1$ Department of Mathematics and Computer Science, University of Bremen,
    Germany \\
    $^2$ Cyber-Physical Systems, DFKI GmbH, Bremen, Germany
  }
}

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\section{Introduction}
\label{sec:introduction}

\danger Mathias

\section{Related Work}
\label{sec:related-work}

\danger Mathias, Sketching, Software synthesis, Model finding, \dots

\section{Preliminaries}
\label{sec:preliminaries}

\ldots

\subsection{Java Virtual Machine}
\label{sec:prelim_jvm}

The \emph{Java Virtual Machine~(JVM)} is the interpreter for compiled java
binary code. The JVM is the part of the java environment, that abstracts from
the respective platform, so the interpreted programs are platform-independent.

\begin{figure}[!ht]
  \centering
  JVM Description Graphic
  \caption{Java Virtual Machine}
\end{figure}

The interpreted binary code is called \emph{java bytecode}. This bytecode is
similar to the Assembler-Code on regular processors or microcontrollers.

\subsection{Java Class File Disassembler}
\label{sec:prelim_javap}

The \emph{Java Class File Disassembler~(javap)} is a class file disassembler
that reconstructs the bytecode from one or more java class files. The program
is delivered with the \emph{Java Development Kit~(JDK)}.

\subsection{Satisfiability Modulo Theories}
\label{sec:prelim_smt}

\danger Mathias

\section{Example -- Graph-Coloring}
\label{sec:example}

An illustrative Example for an application of the described approach is the
Graph-Coloring Problem. The setup for that problem is given by the
Listings~\ref{lst:graph_coloring_vertex} to~\ref{lst:graph_coloring_graph}.

\begin{lstlisting}[language=java,label=lst:graph_coloring_vertex,
    caption=Example -- Vertex]
public class Vertex {
	private int color;
	...
}
\end{lstlisting}

A graph consist of \emph{vertices}~(\prettyref{lst:graph_coloring_vertex}) and
\emph{edges}~(\prettyref{lst:graph_coloring_edge}). Edges are connectors
between two vertices. Every vertex has a \emph{color}-attribute~(here
represented by an integer).

\begin{lstlisting}[language=java,label=lst:graph_coloring_edge,
    caption=Example -- Edge]
public class Edge {
    private Vertex vertex1;
    private Vertex vertex2;
    ...
}
\end{lstlisting}

A explicit graph is represented by a
\emph{graph object}~(\prettyref{lst:graph_coloring_graph}), that consists of a
collection of vertices and edges between those.

\begin{lstlisting}[language=java,label=lst:graph_coloring_graph,
  caption=Example -- Graph]
public class Graph {
    private Collection<Vertex> vertices;
    private Collection<Edge> edges;

    public boolean adjacentsHaveDifferentColors(Edge edge) {
        return edge.getVertex1().getColor() != edge.getVertex2().getColor();
    }
    ...
}
\end{lstlisting}

For an accepting graph there are \emph{constraints} that this graph must
fulfill. For this example there is the constraint, that two vertices, that are
connected by an edge, must have different
colors~(\emph{adjacentsHaveDifferentColors(Edge)}).

\danger show how to proceed without tool

\section{Implementation}
\label{sec:implementation}

\danger Partition into sub-sections (Max)

\subsection{Overview of the Architecture}
\label{sec:impl_overv-arch}

\danger First draft of the flow (Max), maybe part of implementation

\danger perhaps as introduction for this section, ergo no subsection ``Overview
of the Architecture''?

\begin{figure*}[!ht]
  \centering
  \label{fig:architecture}
  \tikzarchitecture
  \caption{Overview of the Architecture}
\end{figure*}

\subsection{Disassembling class-Files}
\label{sec:impl_disassembling}

\danger using javap to decompile and convert every string line into a abstract
object and add this to a map from line numbers to abstract line objects

\subsection{Decompiling the Bytecode}
\label{sec:impl_decompiling}

\danger move through the abstract line objects and reconstruct the constraints
from that

\subsection{Apply Constraints on Explicit Object}
\label{sec:impl_applying}

\danger iterate over all collections matching the parameters of the constraints
and create a constraint for that assignment

\section{Experimental Evaluation}
\label{sec:exper-eval}

\danger Experimental setup (Max)

\danger implementations for same problem by students/other people --> compared
versions; currently waiting for first implementations

\section{Threats To Validity}
\label{sec:threats-validity}

\danger Questions (Mathias)

\section{Conclusions}
\label{sec:conclusions}

\danger In the end (Mathias)

\section*{Acknowledgments}
\label{sec:acknowledgments}
This work was supported by the German Federal Ministry of Education and
Research~(BMBF)~(01IW13001) within the project SPECifIC and by the German
Research Foundation~(DFG)~(DR 287/23-1) within a \emph{Reinhart-Koselleck}
project.


%\bibliographystyle{IEEEtran}
%\bibliography{refs}


\end{document}



%%% Local Variables:
%%% mode: latex
%%% mode: fci
%%% mode: flyspell
%%% mode: auto-fill
%%% mode: whitespace
%%% mode: reftex
%%% TeX-master: t
%%% End:
